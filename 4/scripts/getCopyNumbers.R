# Parses copy number data and folders generated by Snakemake TitanCNA.
# The output data is stored in files that are used elsewhere to generate figures.
#
# writes data/cna.csv file
# writes data/segs.RData and data/sets_singleClone.Rdata files

rm(list=ls())

library(data.table)
library(Homo.sapiens)  # hg19 genome annotation
library(sslist)
library(TitanCNA)
library(rlist)


setwd("~/GoogleDrive/projects/cambridge/ovarianCancerHeterogeneityChemo/repo/HGSOC_TME_Heterogeneity/4")

source("lib/parse.R")

# Results directory from TitanCNA
results_dir = "/Users/koplev01/mnt/mmlab_data/projects/OVCT/titanCNA/TitanCNA/scripts/snakemake"

# Load TitanCNA results table
opt_clust = loadOptClust(file.path(results_dir, "OVCT_results/titan/hmm/optimalClusterSolution.txt"))

# Load all optimal fits
d = loadTitanResultsEnv(
	paste0("OVCT_", opt_clust$path),
	results_dir)

# evaluate segments of copy-number calls from TitanCNA
segs = lapply(1:nrow(opt_clust), function(i) {
	message(i)
	s = outputTitanSegments(d[[i]]$results, id=opt_clust$id[i], d[[i]]$convergeParams)
	return(s)
})

# Calculate non-integer copy numbers
segs = lapply(segs, function(s) {
	# Assumes that remaining cancer cells for subclonal calls are diploid
	s$Copy_Number_Noninteger = s$Cellular_Frequency * s$Copy_Number + 2 * (1 - s$Cellular_Frequency)

	# (Rare) segments without clonal calls, use copy number calls
	idx = is.na(s$Clonal_Cluster)
	s$Copy_Number_Noninteger[idx] = s$Copy_Number[idx]
	message("Calls wihtout subclones: ", sum(idx))
	return(s)
})

# Check output
data.frame(segs[[11]])

# Save list of CNA segments
save(segs, file="data/segs.RData")
# load(file="data/segs.RData", verbose=TRUE)

# # Split elements by clone (INCORRECT)
# segs_subclonal = list()
# for (i in 1:length(segs)) {
# 	s = segs[[i]]
# 	for (j in 1:max(s$Clonal_Cluster, na.rm=TRUE)) {
# 		message(j)
# 		sub_s = s[s$Clonal_Cluster == j, ]
# 		segs_subclonal = list.append(segs_subclonal, sub_s)  # append
# 	}
# }

# Format segments for use with mageGRangesFromDataFrame()
segs_format = lapply(segs, function(s) {
	s$Chromosome = paste0("chr", s$Chromosome)
	s$start = s$Start_Position.bp.
	s$end = s$End_Position.bp.
	return(s)
})

# Load fits with 1 clone specified
d_single = loadTitanResultsEnv(
	paste0("results/titan/hmm/titanCNA_ploidy2/", as.character(opt_clust$barcode), "_cluster1"),
	results_dir)

segs_single = lapply(1:length(d_single), function(i) {
	message(i)
	s = outputTitanSegments(d_single[[i]]$results, id=opt_clust$barcode[i], d_single[[i]]$convergeParams)
})

save(segs_single, file="data/segs_singleClone.RData")

# lapply(segs_single, function(x) unique(x$Clonal_Cluster))
# lapply(segs_single, function(x) nrow(x))
lapply(segs_single, function(x) table(x$Copy_Number))

# Evaluate copy numbers for all gene intervals
annot_cna_mat = segmentGeneFeatures(segs_format, feature="Copy_Number")

write.csv(annot_cna_mat, file="data/cna.csv", row.names=FALSE)
